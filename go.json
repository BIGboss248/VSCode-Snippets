{
    /*

This is a collection of common code snippets for various programming tasks and patterns. https://chatgpt.com/s/t_68df9213365881919b46bdeeb98c848d

ðŸ”¹ 1. Program Structure

boilerplate/skeletonâ†’ basic executable program structure

Libary boilerplate / Libary skeleton â†’ basic Libary/package structure

import / include â†’ add library or dependency

comment â†’ single line / multi-line comment

ðŸ”¹ 2. Variables & Data Types

var â†’ declare variable

var-os â†’ Read environment variable

const â†’ declare constant

type â†’ declare with type annotation (if supported)

assign â†’ variable assignment

Convert â†’ type conversion/casting

ðŸ”¹ 3. Input & Output

print â†’ print to console

print format â†’ print to console

input â†’ read input from user

readfile â†’ read from a file

writefile â†’ write to a file

ðŸ”¹ 4. Control Flow

if â†’ if statement

ifelse â†’ if-else

switch/match â†’ switch/case or match expression

for â†’ for loop (counter-based)

foreach â†’ loop over collection

while â†’ while loop

break â†’ break out of loop

continue â†’ continue to next iteration

ðŸ”¹ 5. Functions

func â†’ function definition

unit-test â†’ function test definition

return â†’ return from function

lambda â†’ anonymous function

ðŸ”¹ 6. Data-Structures

array â†’ array/list

array append â†’ append to array/list

dict/map â†’ dictionary, hash map

set â†’ set

struct / class â†’ basic class or struct

Json-read â†’ parse/serialize JSON

Json-write â†’ generate JSON from data

CSV-read â†’ parse CSV file

ðŸ”¹ 7. Error-Handling

trycatch â†’ try/catch block

throw / raise â†’ throw an error

finally â†’ cleanup section

ðŸ”¹ 8. Common Patterns

loopfile â†’ loop through file lines

looparray â†’ iterate over an array

loopdict â†’ iterate over dictionary/map

main â†’ entry point

ðŸ”¹ 9. Concurrent and parallelism

asyncfunc â†’ async function

await â†’ await promise/future

thread â†’ threading/multithreading snippet

class â†’ class definition

inherit â†’ class inheritance

ðŸ”¹ 10. Debugging & Utilities

hashpassword â†’ securely hash a password

JWT-generate â†’ generate JWT token   

JWT-validate â†’ validate JWT token


ðŸ”¹ 11. Database

dbconnect â†’ connect to a database

dbqueryrows â†’ query multiple rows

dbqueryrow â†’ query a single row

dbexec â†’ execute insert/update/delete

dbtx â†’ transaction with commit/rollback

dbclose â†’ close database connection safely

dbping â†’ check database health/connection

ðŸ”¹ 12. APIâ€“Server (exposing APIs)

apiserver â†’ start an HTTP server

apiroute â†’ define a route/endpoint handler

apiparsejson â†’ parse request body JSON

apiresjson â†’ send JSON response

apimiddleware â†’ add middleware (logging, auth, CORS)

ðŸ”¹ 13. APIâ€“Client (consuming APIs)

apiclientget â†’ make GET request to external API

apiclientpost â†’ make POST request to external API

apiclientreq â†’ generic HTTP request with headers

apiclientjson â†’ parse JSON response into struct
*/
    "Authentication middleware": {
        "prefix": "!apimiddleware gin authentication",
        "body": [
            "",
            "/*",
            "",
            "AuthMiddleWare",
            "",
            "Validates JWT token from cookie or Authorization header and alllows access to protected routes",
            "",
            "Tip To add middleware to endpoints you need to use router.Use(middleware-name) before defining enndpoints all endpoints defined after router.Use in **that function** will use the middleware so for auth endpoints for example if there are some routes using the middleware and some don't you need to define two functions to define protected and unprotected routes separately so not all routes use the middleware.",
            "",
            "",
            "",
            "*/",
            "func AuthMiddleWare() gin.HandlerFunc {",
            "\treturn func(c *gin.Context) {",
            "\t\t//TODO Implement function to get access token from request either cookie (which is preferred) or Authorization header",
            "\t\ttoken, err := utils.GetAccessToken(c)",
            "",
            "\t\tif err != nil {",
            "\t\t\tc.JSON(http.StatusUnauthorized, gin.H{\"error\": err.Error()})",
            "\t\t\tc.Abort()",
            "\t\t\treturn",
            "\t\t}",
            "\t\tif token == \"\" {",
            "\t\t\tc.JSON(http.StatusUnauthorized, gin.H{\"error\": \"No token provided\"})",
            "\t\t\tc.Abort()",
            "\t\t\treturn",
            "\t\t}",
            "",
            "\t\tclaims, err := utils.ValidateToken(token)",
            "",
            "\t\tif err != nil {",
            "\t\t\tc.JSON(http.StatusUnauthorized, gin.H{\"error\": \"Invalid token\"})",
            "\t\t\tc.Abort()",
            "\t\t\treturn",
            "\t\t}",
            "\t\tc.Set(\"userId\", claims.UserId)",
            "\t\tc.Set(\"role\", claims.Role)",
            "",
            "\t\tc.Next()",
            "",
            "\t}",
            "}",
            ""
        ],
        "description": "Define authentication middleware"
    },
    "API JWT auth login": {
        "prefix": [
            "!apimiddleware gin JWT login",
            "!apimiddleware gin JWT Logout"
        ],
        "body": [
            "",
            "import (",
            "\t\"context\"",
            "\t\"net/http\"",
            "\t\"time\"",
            "",
            "\t\"github.com/gin-gonic/gin\"",
            "\t\"go.mongodb.org/mongo-driver/v2/bson\"",
            "\t\"go.mongodb.org/mongo-driver/v2/mongo\"",
            "\t\"golang.org/x/crypto/bcrypt\"",
            ")",
            "",
            "",
            "//TODO Implement USER, UserLogin and UserResponse according to your app requirements",
            "//TODO Add and edit tags for validator and json as needed",
            "type User struct {",
            "\tID\t\t   bson.ObjectID `json:\"_id,omitempty\" bson:\"_id,omitempty\"`",
            "\tUserID\t   string\t\t`json:\"user_id\" bson:\"user_id\"`",
            "\tFirstName\tstring\t\t`json:\"first_name\" bson:\"first_name\" validate:\"required,min=2,max=100\"`",
            "\tLastName\t string\t\t`json:\"last_name\" bson:\"last_name\" validate:\"required,min=2,max=100\"`",
            "\tEmail\t\tstring\t\t`json:\"email\" bson:\"email\" validate:\"required,email\"`",
            "\tPassword\t string\t\t`json:\"password\" bson:\"password\" validate:\"required,min=6\"`",
            "\tRole\t\t string\t\t`json:\"role\" bson:\"role\" validate:\"oneof=ADMIN USER\"`",
            "\tCreatedAt\ttime.Time\t `json:\"created_at\" bson:\"created_at\"`",
            "\tUpdatedAt\ttime.Time\t `json:\"update_at\" bson:\"update_at\"`",
            "\tToken\t\tstring\t\t`json:\"token\" bson:\"token\"`",
            "\tRefreshToken string\t\t`json:\"refresh_token\" bson:\"refresh_token\"`",
            "}",
            "type UserLogin struct {",
            "\tEmail\tstring `json:\"email\" validate:\"required,email\"`",
            "\tPassword string `json:\"password\" validate:\"required,min=6\"`",
            "}",
            "type UserResponse struct {",
            "\tUserId\t   string `json:\"user_id\"`",
            "\tFirstName\tstring `json:\"first_name\"`",
            "\tLastName\t string `json:\"last_name\"`",
            "\tEmail\t\tstring `json:\"email\"`",
            "\tRole\t\t string `json:\"role\"`",
            "\tToken\t\tstring `json:\"token\"`",
            "\tRefreshToken string `json:\"refresh_token\"`",
            "}",
            "",
            "",
            "",
            "",
            "",
            "/*",
            "",
            "# LoginUser",
            "",
            "Gin handler function to authenticate a user and provide JWT tokens upon successful login.",
            "",
            "TODO implement databsse functions",
            "",
            "Tip you can use !JWT-Generate to create functions for generating and validating JWT tokens",
            "",
            "Tip: This function will:",
            "",
            "",
            "1. validate the user body to make sure all needed information is persent (using struct tags gin will vaLidate itself using golang validator) ",
            "",
            "2. get user's username (in most cases email) and password from the request body ",
            "",
            "3. query the database to find the user with the given email ",
            "",
            "4. compare the provided password with the hashed password stored in the database using bcrypt",
            "",
            "5. generate JWT token and refresh token upon successful authentication",
            "",
            "6. store the generated tokens in the database under the user's record",
            "",
            "7. set the tokens as HttpOnly cookies in the response",
            "",
            "8. return user details in the response body (excluding password) along cookies with the tokens.",
            "",
            "# Parameters",
            "",
            "- client: A MongoDB client instance used to interact with the database.",
            "",
            "- userLogin: A UserLogin struct containing the email and password provided by the user.",
            "",
            "# Returns",
            "",
            "- A Gin handler function that processes the login request.",
            "",
            "",
            "",
            "*/",
            "func LoginUser(client *mongo.Client, userLogin UserLogin, dbTimeOut time.Duration) gin.HandlerFunc {",
            "\treturn func(c *gin.Context) {",
            "",
            "\t\t// 1. validate the user body to make sure all needed information is persent (using struct tags gin will vaLidate itself using golang validator) ",
            "\t\t// 2. get user's username (in most cases email) and password from the request body",
            "\t\tif err := c.ShouldBindJSON(&userLogin); err != nil {",
            "\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Invalide input data\"})",
            "\t\t\treturn",
            "\t\t}",
            "",
            "\t\t// Set a timeout to avoid long running operations",
            "\t\tvar ctx, cancel = context.WithTimeout(c, dbTimeOut)",
            "\t\tdefer cancel()",
            "",
            "\t\t// 3. query the database to find the user with the given email",
            "\t\t// TODO Implement function to query the database for user's email and password",
            "\t\tvar userCollection *mongo.Collection = database.OpenCollection(\"users\", client)",
            "",
            "\t\tvar foundUser User",
            "\t\terr := userCollection.FindOne(ctx, bson.D{{Key: \"email\", Value: userLogin.Email}}).Decode(&foundUser)",
            "\t\tif err != nil {",
            "\t\t\tc.JSON(http.StatusUnauthorized, gin.H{\"error\": \"Invalid email or password\"})",
            "\t\t\treturn",
            "\t\t}",
            "",
            "\t\t// 4. compare the provided password with the hashed password stored in the database using bcrypt",
            "\t\t//TODO Implement password comparison function using bcrypt",
            "\t\terr = bcrypt.CompareHashAndPassword([]byte(foundUser.Password), []byte(userLogin.Password))",
            "\t\tif err != nil {",
            "\t\t\tc.JSON(http.StatusUnauthorized, gin.H{\"error\": \"Invalid email or password\"})",
            "\t\t\treturn",
            "\t\t}",
            "",
            "\t\t// 5. generate JWT token and refresh token upon successful authentication",
            "\t\ttoken, refreshToken, err := utils.GenerateAllTokens(foundUser.Email, foundUser.FirstName, foundUser.LastName, foundUser.Role, foundUser.UserID)",
            "",
            "\t\tif err != nil {",
            "\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to generate tokens\"})",
            "\t\t\treturn",
            "\t\t}",
            "",
            "\t\t// 6. store the generated tokens in the database under the user's record",
            "\t\terr = utils.UpdateAllTokens(foundUser.UserID, token, refreshToken, client)",
            "",
            "\t\tif err != nil {",
            "\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to update tokens\"})",
            "\t\t\treturn",
            "\t\t}",
            "",
            "\t\t// 7. set the tokens as HttpOnly cookies in the response",
            "",
            "\t\t// Set the token as HttpOnly cookies",
            "\t\thttp.SetCookie(c.Writer, &http.Cookie{",
            "\t\t\tName:  \"access_token\",",
            "\t\t\tValue: token,",
            "\t\t\tPath:  \"/\",",
            "\t\t\t// Domain:   \"localhost\",",
            "\t\t\tMaxAge:   86400,",
            "\t\t\tSecure:   true,",
            "\t\t\tHttpOnly: true,",
            "\t\t\tSameSite: http.SameSiteNoneMode,",
            "\t\t})",
            "",
            "\t\t// Set the refresh token as HttpOnly cookies",
            "\t\thttp.SetCookie(c.Writer, &http.Cookie{",
            "\t\t\tName:  \"refresh_token\",",
            "\t\t\tValue: refreshToken,",
            "\t\t\tPath:  \"/\",",
            "\t\t\t// Domain:   \"localhost\",",
            "\t\t\tMaxAge:   604800,",
            "\t\t\tSecure:   true,",
            "\t\t\tHttpOnly: true,",
            "\t\t\tSameSite: http.SameSiteNoneMode,",
            "\t\t})",
            "",
            "\t\t// 8. return user details in the response body (excluding password) along cookies with the tokens.",
            "\t\tc.JSON(http.StatusOK, UserResponse{",
            "\t\t\tUserId:\tfoundUser.UserID,",
            "\t\t\tFirstName: foundUser.FirstName,",
            "\t\t\tLastName:  foundUser.LastName,",
            "\t\t\tEmail:\t foundUser.Email,",
            "\t\t\tRole:\t  foundUser.Role,",
            "\t\t\t//Token:\t\t   token,",
            "\t\t\t//RefreshToken:\trefreshToken,",
            "\t\t\t//todo add other fields if needed",
            "\t\t})",
            "",
            "\t}",
            "}",
            "",
            "/*",
            "",
            "# LogoutHandler",
            "",
            "Gin handler function to log out a user by clearing their JWT tokens.",
            "",
            "Tip: This function will:",
            "",
            "1. Retrieve the user ID from the request body.",
            "",
            "2. Clear the access and refresh tokens in the database for the specified user.",
            "",
            "3. Clear the access_token and refresh_token cookies by setting them with a negative MaxAge.",
            "",
            "4. Return a success message upon successful logout.",
            "",
            "",
            "# Parameters",
            "",
            "- client: A MongoDB client instance used to interact with the database.",
            "",
            "# Returns",
            "",
            "- A Gin handler function that processes the logout request.",
            "",
            "",
            "*/",
            "func LogoutHandler(client *mongo.Client) gin.HandlerFunc {",
            "\treturn func(c *gin.Context) {",
            "\t\t// Clear the access_token cookie",
            "",
            "\t\tvar UserLogout struct {",
            "\t\t\tUserId string `json:\"user_id\"`",
            "\t\t}",
            "",
            "\t\terr := c.ShouldBindJSON(&UserLogout)",
            "\t\tif err != nil {",
            "\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid request payload\"})",
            "\t\t\treturn",
            "\t\t}",
            "",
            "\t\tfmt.Println(\"User ID from Logout request:\", UserLogout.UserId)",
            "",
            "\t\t//Todo Based on your database implement the function to find user record and clear the tokens",
            "\t\terr = utils.UpdateAllTokens(UserLogout.UserId, \"\", \"\", client) // Clear tokens in the database",
            "\t\t// Optionally, you can also remove the user session from the database if needed",
            "",
            "\t\tif err != nil {",
            "\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Error logging out\"})",
            "\t\t\treturn",
            "\t\t}",
            "\t\t// c.SetCookie(",
            "\t\t// \t\"access_token\",",
            "\t\t// \t\"\",",
            "\t\t// \t-1, // MaxAge negative â†’ delete immediately",
            "\t\t// \t\"/\",",
            "\t\t// \t\"localhost\", // Adjust to your domain",
            "\t\t// \ttrue,\t\t// Use true in production with HTTPS",
            "\t\t// \ttrue,\t\t// HttpOnly",
            "\t\t// )",
            "\t\thttp.SetCookie(c.Writer, &http.Cookie{",
            "\t\t\tName:  \"access_token\",",
            "\t\t\tValue: \"\",",
            "\t\t\tPath:  \"/\",",
            "\t\t\t// Domain:   \"localhost\",",
            "\t\t\tMaxAge:   -1,",
            "\t\t\tSecure:   true,",
            "\t\t\tHttpOnly: true,",
            "\t\t\tSameSite: http.SameSiteNoneMode,",
            "\t\t})",
            "",
            "\t\t// // Clear the refresh_token cookie",
            "\t\t// c.SetCookie(",
            "\t\t// \t\"refresh_token\",",
            "\t\t// \t\"\",",
            "\t\t// \t-1,",
            "\t\t// \t\"/\",",
            "\t\t// \t\"localhost\",",
            "\t\t// \ttrue,",
            "\t\t// \ttrue,",
            "\t\t// )",
            "\t\thttp.SetCookie(c.Writer, &http.Cookie{",
            "\t\t\tName:\t \"refresh_token\",",
            "\t\t\tValue:\t\"\",",
            "\t\t\tPath:\t \"/\",",
            "\t\t\tMaxAge:   -1,",
            "\t\t\tSecure:   true,",
            "\t\t\tHttpOnly: true,",
            "\t\t\tSameSite: http.SameSiteNoneMode,",
            "\t\t})",
            "",
            "\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"Logged out successfully\"})",
            "\t}",
            "}",
            ""
        ],
        "description": "Create a gin handler function to validate user credentials from databse and issue token and refresh tokens",
        "isFileTemplate": true
    },
    "Generate and validate JWT token": {
        "prefix": [
            "!JWT-generate _Debugging & Utilities_",
            "!JWT-validate _Debugging & Utilities_"
        ],
        "body": [
            "// This code snippet will generate funcitons on generating and validating JWT tokens and refresh tokens",
            "",
            "import jwt \"github.com/golang-jwt/jwt/v5\"",
            "",
            "type encoded_auth struct {",
            "\t${1:Properties-encoded-in-token}\t${2:property-type}",
            "\tjwt.RegisteredClaims",
            "}",
            "",
            "var SECRET_KEY string = os.Getenv(\"SECRET_KEY\")",
            "var SECRET_REFRESH_KEY string = os.Getenv(\"SECRET_REFRESH_KEY\")",
            "",
            "func GenerateAllTokens(${1:Properties-encoded-in-token} ${2:property-type}, valid-time time.Duration, valid-time-refresh time.Duration) (string, string, error) {",
            "",
            "\tclaims := &encoded_auth{",
            "\t\t${1:Properties-encoded-in-token}: ${2:property-type},",
            "\t\tRegisteredClaims: jwt.RegisteredClaims{",
            "\t\t\tIssuer:   \"${3:Issuer-name}\",",
            "\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().Add(valid-time)),",
            "\t\t\tIssuedAt:  jwt.NewNumericDate(time.Now()),",
            "\t\t},",
            "\t}",
            "\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)",
            "\tsignedToken, err := token.SignedString([]byte(SECRET_KEY))",
            "\tif err != nil {",
            "\t\treturn \"\", \"\", err",
            "\t}",
            "\trefreshClaims := &SignedDetails{",
            "\t\t${1:Properties-encoded-in-token}: ${2:property-type},",
            "\t\tRegisteredClaims: jwt.RegisteredClaims{",
            "\t\t\tIssuer:   \"${3:Issuer-name}\",",
            "\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().Add(valid-time-refresh)),",
            "\t\t\tIssuedAt:  jwt.NewNumericDate(time.Now()),",
            "\t\t},",
            "\t}",
            "\t\trefreshToken := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshClaims)",
            "\tsignedRefreshToken, err := refreshToken.SignedString([]byte(SECRET_REFRESH_KEY))",
            "",
            "\tif err != nil {",
            "\t\treturn \"\", \"\", err",
            "\t}",
            "",
            "\treturn signedToken, signedRefreshToken, nil",
            "",
            "}",
            "",
            "func ValidateToken(tokenString, SECRET_KEY string) (*encoded_auth, error) {",
            "claims := &encoded_auth{}",
            "token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {",
            "    return []byte(SECRET_KEY), nil",
            "})",
            "if err != nil {",
            "    return nil, err",
            "}",
            "if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {",
            "    return nil, err",
            "}",
            "if claims.ExpiresAt.Time.Before(time.Now()) {",
            "    return nil, errors.New(\"token has expired\")",
            "}",
            "return claims, nil",
            "}",
            "",
            "func ValidateRefreshToken(tokenString, SECRET_Refresh_KEY string) (*encoded_auth, error) {",
            "claims := &encoded_auth{}",
            "token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {",
            "    return []byte(SECRET_Refresh_KEY), nil",
            "})",
            "if err != nil {",
            "    return nil, err",
            "}",
            "if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {",
            "    return nil, err",
            "}",
            "if claims.ExpiresAt.Time.Before(time.Now()) {",
            "    return nil, errors.New(\"refresh token has expired\")",
            "}",
            "return claims, nil",
            "}",
            "",
        ],
        "description": "Create functions to generate and validate JWT tokens and refresh tokens"
    },
    "gin route": {
        "prefix": "!apiroute gin _API-Server_",
        "description": "Create a route for created gin api server",
        "body": [
            "//tip gin context can control the flow and be used to halt execution and free resource if user refreshes or cancels the request",
            "/*",
            "# ${4:function_name}",
            "",
            "Function to handle ${1|GET,POST,PUT,DELETE,PATCH,HEAD,OPTIONS|} requests at the path /${2:path}/:${3:param-name}",
            "",
            "# Packages",
            "",
            "  1. \"github.com/gin-gonic/gin\": gin web framework",
            "  2. \"github.com/rs/zerolog\": logging package",
            "",
            "# Parameters",
            "",
            "  1. logger: zerolog.Logger - logger object.",
            "",
            "# Returns",
            "",
            "  - func(c *gin.Context): gin handler function to handle the request.",
            "",
            "",
            "*/",
            "func ${4:function_name}(logger zerolog.Logger)(func(c *gin.Context)){",
            "${4:function_name}StartTime := time.Now() // Record start time",
            "logger.Debug().Str(\"FunctionName:\",\"${4:function_name}\").Msg(\"${4:function_name} function started\")",
            "defer func() {",
            "logger.Debug().Str(\"FunctionName:\",\"${4:function_name}\").TimeDiff(\"Duration (ms)\", time.Now(), ${4:function_name}StartTime).Msg(\"${4:function_name} function ended.\")",
            "}()",
            "return func(c *gin.Context) {",
            "name := c.Param(\"${3:param-name}\")",
            "c.${6|JSON,XML,YAML|}(http.StatusOK, gin.H{\"message\": \"Hello\" + name})",
            "${5://todo remove sample code and implement your logic here}",
            "}",
            "}",
            "//* Don't forget to create router using !apiserver gin snippet",
            "//tip :${3:param-name} is a path parameter usefull for getting dynamic values from the URL",
            "router.${1|GET,POST,PUT,DELETE,PATCH,HEAD,OPTIONS|}(\"/${2:path}/:${3:param-name}\", ${4:function_name}(logger))",
        ]
    },
    "gin API server": {
        "prefix": "!apiserver gin create _APIâ€“Server_",
        "body": [
            "//$ go get github.com/gin-gonic/gin",
            "//tip If you plan to create an API server use a principle like REST or GraphQL to design your API endpoints and data structures before implementing the server.",
            "router := gin.Default()",
            "router.SetTrustedProxies([]string{${5:\"127.0.0.1\"}})",
            // "//tip :${3:param} is a path parameter usefull for getting dynamic values from the URL",
            // "router.${1|GET,POST,PUT,DELETE,PATCH,HEAD,OPTIONS|}(\"/${2:path}/:${3:param}\", func(c *gin.Context) {",
            // "name := c.Param(\"name\")",
            // "c.String(http.StatusOK, \"Hello %s\", name)",
            // "})",
            "// Add routes before run and after router declaration you can use !apiroute vscode snippet",
            "router.Run(\":${4:port}\") // listen and serve on ${4:port}",
        ],
        "description": "Create a gin router and configure trusted proxies"
    },
"gin parse json body": {
        "prefix": "!apiparsejson gin _APIâ€“Server_",
        "description": "Parse user sent json",
        "body": [
            "//tip how gin works is you will define a struct representing the expected json body and gin will automatically bind the incoming json to that struct based on the json tags defined in the struct fields",
            "//* tags are important to map json fields to struct fields",
            "type ${6:structType} struct {",
            "    Name  string `json:\"name\"`",
            "    Email string `json:\"email\"`",
            "    Age   int    `json:\"age\"`",
            "}",
            "",
            "/*",
            "# ${4:function_name}",
            "",
            "Function to handle ${1|GET,POST,PUT,DELETE,PATCH,HEAD,OPTIONS|} requests at the path /${2:path}/:${3:param-name}",
            "",
            "# Packages",
            "",
            "  1. \"github.com/gin-gonic/gin\": gin web framework",
            "  2. \"github.com/rs/zerolog\": logging package",
            "",
            "# Parameters",
            "",
            "  1. logger: zerolog.Logger - logger object.",
            "",
            "# Returns",
            "",
            "  - func(c *gin.Context): gin handler function to handle the request.",
            "",
            "",
            "*/",
            "func ${4:function_name}(logger zerolog.Logger)(func(c *gin.Context)){",
            "${4:function_name}StartTime := time.Now() // Record start time",
            "logger.Debug().Str(\"FunctionName:\",\"${4:function_name}\").Msg(\"${4:function_name} function started\")",
            "defer func() {",
            "logger.Debug().Str(\"FunctionName:\",\"${4:function_name}\").TimeDiff(\"Duration (ms)\", time.Now(), ${4:function_name}StartTime).Msg(\"${4:function_name} function ended.\")",
            "}()",
            "return func(c *gin.Context) {",
            "name := c.Param(\"${3:param-name}\")",
            "c.String(http.StatusOK, \"Hello %s\", name)",
            "    // Create a User struct to hold the parsed data",
            "    var ${7:objectName} ${6:structType}",
            "    // Bind the JSON body to the ${6:structType} struct instance created",
            "    // gin uses go-playground/validator/v10 for validation based on struct tags for more info see https://github.com/gin-gonic/gin/blob/master/docs/doc.md#model-binding-and-validation",
            "    if err := c.ShouldBindJSON(&user); err != nil {",
            "        // Handle error if JSON is invalid or doesn't match the struct",
            "        c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})",
            "        return",
            "    }",
            "    // Use user data and send back response",
            "    c.${8|JSON,XML,YAML|}(http.StatusOK, gin.H{\"message\": \"${6:structType} received\", \"${6:structType}\": ${7:objectName}})",
            "${15://todo remove sample code and implement your logic here}",
            "}",
            "}",
            "// Example route to bind JSON body into User struct",
            "router.POST(\"/user\", ${4:function_name}(logger))",
        ]
    },
    "database mongodb create collection": {
        "prefix": "!dbexec mongodb create collection _Database_",
        "body": [
            "/*",
            "# MongoDatabaseCreateCollection",
            "",
            "Create a collection in the specified database",
            "",
            "# Packages",
            "",
            "1. go.mongodb.org/mongo-driver/v2/mongo: mongo driver",
            "",
            "2. go.mongodb.org/mongo-driver/v2/mongo/options: mongo driver options",
            "",
            "3. github.com/rs/zerolog: logging package",
            "",
            "4. context: for context and timeout handling",
            "",
            "5. time: for time handling",
            "",
            "# Parameters",
            "",
            "1. logger: zerolog.Logger - logger object.",
            "",
            "2. client: *mongo.Client - mongo client connection object.",
            "",
            "3. DatabaseName: string - name of the database.",
            "",
            "4. CollectionName: string - name of the collection to be created.",
            "",
            "5. timeout: time.Duration - timeout duration for the operation.",
            "",
            "# Returns",
            "",
            "1. error: error if any error occurs during the operation else nil",
            "",
            "*/",
            "func MongoDatabaseCreateCollection(logger zerolog.Logger, client *mongo.Client, DatabaseName string, CollectionName string, timeout time.Duration) error {",
            "\tMongoDatabaseCreateCollectionStartTime := time.Now() // Record start time",
            "\tlogger.Debug().Str(\"FunctionName:\", \"MongoDatabaseCreateCollection\").Msg(\"MongoDatabaseCreateCollection function started\")",
            "\tdefer func() {",
            "\t\tlogger.Debug().Str(\"FunctionName:\", \"MongoDatabaseCreateCollection\").TimeDiff(\"Duration (ms)\", time.Now(), MongoDatabaseCreateCollectionStartTime).Msg(\"MongoDatabaseCreateCollection function ended.\")",
            "\t}()",
            "\tif client == nil || DatabaseName == \"\" || CollectionName == \"\" {",
            "\t\terr := fmt.Errorf(\"missing required parameters\")",
            "\t\tlogger.Error().Err(err).Msg(\"Missing required parameters\")",
            "\t\treturn err",
            "\t}",
            "\tctx, cancel := context.WithTimeout(context.Background(), timeout)",
            "\tdefer cancel()",
            "\terr := client.Database(DatabaseName).CreateCollection(ctx, CollectionName)",
            "\tif err != nil {",
            "\t\tlogger.Error().Err(err).Msg(\"Failed to create collection\")",
            "\t\treturn err",
            "\t}",
            "\tlogger.Info().Msg(\"âœ… Successfully created collection\")",
            "\treturn nil",
            "}",
            ""
        ],
        "description": "Create a function to get inputs and create a collection in mongodb database"
    },
    "Operating system variable": {
        "prefix": "!os-var _Variables & Data Types_",
        "body": [
            "import \"os\"",
            "//! Be sure to check for empty string if the environment variable is not set",
            "var ${1:variableName} string = os.Getenv(\"${2:ENV_VARIABLE_NAME}\") // Read environment variable"
        ],
        "description": "Read an environment variable from the operating system"
    },
    "connect to mongo db": {
        "body": [
            "import \"go.mongodb.org/mongo-driver/v2/mongo\"",
            "import \"go.mongodb.org/mongo-driver/v2/mongo/options\"",
            "",
            "// mongodb URI: mongodb://ip:port/",
            "clintOptions := options.Client().ApplyURI(${1:mongo db connection string})",
            "",
            "db_client, err := mongo.Connect(clintOptions)",
        ]
    },
    "import packages": {
        "prefix": "!import/include _Program Structure_",
        "body": [
            "import (",
            "\t\"${1:Ailias} ${2:Package}\"",
            ")"
        ],
        "description": "Import/include packages or libraries"
    },
    "Read input from user": {
        "prefix": "!input __Input & Output__",
        "body": [
            "var ${1:variablename} ${4| ,*|}${2|bool,string,int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,uintptr,byte,rune,float32,float64,complex64,complex128|} = ${3:value}",
            "fmt.Scanln(&${1:variablename}) //reads until first newline",
            "fmt.Scan(&${1:variablename}) //reads until first space or newline",
        ],
        "description": "Read input from user and store it in a variable"
    },
    "postgres database connect": {
        "prefix": "!dbconnect postgres _Database_",
        "body": [
            "import \"github.com/rs/zerolog/log\"",
            "import \"github.com/zerolog\"",
            "import \"github.com/jackc/pgx/v5\"",
            "",
            "/*",
            "# postgresConnect",
            "",
            "connects to a PostgreSQL database using the provided credentials and returns a connection object.Close the connection when done.",
            "",
            "# Packages",
            "",
            " - \"github.com/rs/zerolog/log\"",
            " - \"github.com/zerolog\"",
            " - \"github.com/jackc/pgx/v5\"",
            "",
            "# Parameters",
            "",
            "TODO - input_name: input_type - description of the input.",
            "",
            "# Returns",
            "",
            "TODO - output_type - description of the output.",
            "",
            "",
            "*/",
            "func postgresConnect(${1:usename, pass, host_ip, port, dbname string}) (*pgx.Conn, error) {",
            "\tpostgresConnectStartTime := time.Now() // Record start time",
            "\tlogger, err := SetupLogger(\"app.log\", zerolog.InfoLevel)",
            "\tif err != nil {",
            "\tpanic(err)",
            "\t}",
            "\tlogger.Info().Str(\"FunctionName:\",\"postgresConnect\").Msg(\"postgresConnect function started\")",
            "\tdefer func() {",
            "\tlogger.Info().Str(\"FunctionName:\",\"postgresConnect\").TimeDiff(\"Duration (ms)\", time.Now(), postgresConnectStartTime).Msg(\"postgresConnect function ended.\")",
            "\t}()",
            "\tconn_string := \"postgres://\" + usename + \":\" + pass + \"@\" + host_ip + \":\" + port + \"/\" + dbname",
            "\tconn, err := pgx.Connect(context.Background(), conn_string)",
            "\tif err != nil {",
            "\t\treturn nil, err",
            "\t}",
            "\treturn conn, nil",
            "}",
            "",
            "/*",
            "# psotgresQuery",
            "",
            "Query data from a PostgreSQL database using the provided connection and query string.Close the rows when done to use the connection again.",
            "",
            "# Packages",
            "",
            " - \"github.com/rs/zerolog/log\"",
            " - \"github.com/zerolog\"",
            " - \"github.com/jackc/pgx/v5\"",
            " - \"fmt\"",
            "",
            "# Parameters",
            "",
            " - conn: *pgx.Conn - postgres connection created by pgx.Connect.",
            " - Query: string - SQL query to be executed.",
            "",
            "# Returns",
            "",
            " - *pgx.Rows - Rows object.",
            " - error - error if the query fails.",
            "",
            "",
            "*/",
            "func psotgresQuery(conn *pgx.Conn, query string) (*pgx.Rows, error) {",
            "\tpostgresQueryStartTime := time.Now() // Record start time",
            "\t\t// defer keyword will execute a code when the function returns",
            "\tlogger, err := SetupLogger(\"app.log\", zerolog.InfoLevel)",
            "\tif err != nil {",
            "\tpanic(err)",
            "\t}",
            "\tlogger.Info().Str(\"FunctionName:\",\"postgresQuery\").Msg(\"postgresQuery function started\")",
            "\tdefer func() {",
            "\tlogger.Info().Str(\"FunctionName:\",\"postgresQuery\").TimeDiff(\"Duration (ms)\", time.Now(), postgresQueryStartTime).Msg(\"postgresQuery function ended.\")",
            "\t}()",
            "\trows, err := conn.Query(context.Background(), query)",
            "\tif err != nil {",
            "\t\tlog.Fatal().Err(err).Msg(\"Failed to execute query\")",
            "\t}",
            "\tdefer rows.Close()",
            "",
            "${2://TODO Change code if needed}",
            "\treturn rows, nil",
            "}",
            "",
            "${3:defer rows.Close() //! Remember to close the rows when done to use the connection again\ndefer conn.Close(context.Background()) //! Remember to close the connection when done}",
            "",
        ],
        "description": "Create a postgres database connection and another connection to query data"
    },
    "function docstring": {
        "prefix": [
            "!docstring _Comment_",
        ],
        "body": [
            "/*",
            "# ${1:function_name}",
            "",
            "TODO function_description",
            "",
            "# Packages",
            "",
            "TODO - import_package: package_description",
            "",
            "# Parameters",
            "",
            "TODO - input_name: input_type - description of the input.",
            "",
            "# Returns",
            "",
            "TODO - output_type - description of the output.",
            "",
            "",
            "*/",
        ],
        "description": "Create a function with a docstring"
    },
    "function add logger": {
        "prefix": "!funciton add logger _Debugging & Utilities_",
        "body": [
            "${1:function_name}StartTime := time.Now() // Record start time",
            "\t// defer keyword will execute a code when the function returns",
            "logger, err := SetupLogger(\"app.log\", zerolog.InfoLevel)",
            "if err != nil {",
            "panic(err)",
            "}",
            "logger.Info().Str(\"FunctionName:\",\"${1:function name}\").Msg(\"${1:function_name} function started\")",
            "defer func() {",
            "logger.Info().Str(\"FunctionName:\",\"${1:function name}\").TimeDiff(\"Duration (ms)\", time.Now(), ${1:function_name}StartTime).Msg(\"${1:function_name} function ended.\")",
            "}()",
        ],
        "description": "Add a logger to a function to log its start and end time along with execution duration"
    },
    "gqlgen graphql server": {
        "prefix": "!apiserver gqlgen start _APIâ€“Server_",
        "body": [
            "/*",
            "",
            "First initialize the repository with this command",
            "",
            "\\$ go get github.com/99designs/gqlgen",
            "\\$ go run github.com/99designs/gqlgen init",
            "",
            "Write your schema in graph\\schema.graphqls then run the following command to generate the code",
            "",
            "\\$ go get github.com/99designs/gqlgen",
            "\\$ go run github.com/99designs/gqlgen generate",
            "",
            "The codes will be generated now implement the resolvers in graph/resolver.go",
            "",
            "finally run the server with",
            "",
            "\\$ go run main.go",
            "",
            "*/"
        ],
        "description": "Start to implement a gqlgen server"
    },
    "Example Post json content with http": {
        "prefix": "!apiclientpost example net http post json _APIâ€“Client_",
        "body": [
            "type Comment struct {",
            "\tId\t  string `json:\"id\"`",
            "\tUserId  string `json:\"user_id\"`",
            "\tComment string `json:\"comment\"`",
            "}",
            "",
            "func createComment(url, apiKey string, commentStruct Comment) (Comment, error) {",
            "\t// encode our comment as json",
            "\tjsonData, err := json.Marshal(commentStruct)",
            "\tif err != nil {",
            "\t\treturn Comment{}, err",
            "\t}",
            "",
            "\t// create a new request",
            "\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(jsonData))",
            "\tif err != nil {",
            "\t\treturn Comment{}, err",
            "\t}",
            "",
            "\t// set request headers",
            "\treq.Header.Set(\"Content-Type\", \"application/json\")",
            "\treq.Header.Set(\"X-API-Key\", apiKey)",
            "",
            "\t// create a new client and make the request",
            "\tclient := &http.Client{}",
            "\tres, err := client.Do(req)",
            "\tif err != nil {",
            "\t\treturn Comment{}, err",
            "\t}",
            "\tdefer res.Body.Close()",
            "",
            "\t// decode the json data from the response",
            "\t// into a new Comment struct",
            "\tvar comment Comment",
            "\tdecoder := json.NewDecoder(res.Body)",
            "\terr = decoder.Decode(&comment)",
            "\tif err != nil {",
            "\t\treturn Comment{}, err",
            "\t}",
            "",
            "\treturn comment, nil",
            "}"
        ],
        "description": "Post json data with http"
    },
    "Make an HTTP request with headers": {
        "prefix": [
            "!apiclientreq net/http _APIâ€“Client_",
        ],
        "description": "Create a function to make an http request to a URL with headers",
        "body": [
            "/*",
            "httpRequest makes an HTTP request with the specified method, URL, and headers.",
            "tip To declare body type add Content-Type header example application/json",
            "tip To see a post example snippet: !example net http post json",
            "tip For API authentication header can be X-API-KEY",
            "tip For a list of status codes see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status",
            "",
            "Parameters:",
            "  - method: The HTTP method (e.g., \"GET\", \"POST\").",
            "  - URL: The URL to request.",
            "  - reqHeaders: A map of request headers.",
            "",
            "Returns:",
            "  - *http.Response: The HTTP response.",
            "  - error: An error if the request fails.",
            "*/",
            "",
            "func httpRequest(method string,URL string, reqHeaders map[string]string) (*http.Response, error) {",
            "//* import \"net/http\"",
            "\t// creating a new request",
            "\treq, err := http.NewRequest(method, URL, nil)",
            "\tif err != nil {",
            "\t\tlog.Err(err).Msg(\"\")",
            "\t\treturn nil, err",
            "\t}",
            "\t",
            "\tfor index, value := range reqHeaders {",
            "\t\t// reqHeaders element",
            "\t\treq.Header.Set(index, value)",
            "\t}",
            "\t// making the request",
            "\tclient := http.Client{}",
            "\tres, err := client.Do(req)",
            "\tif err != nil {",
            "\t\tlog.Err(err).Msg(\"\")",
            "\t\treturn nil, err",
            "\t}",
            "\tif res.StatusCode != http.StatusOK {",
            "\t\terr := fmt.Errorf(\"Error HTTTP request failed with status code: %s\", res.Status)",
            "\t\tlog.Err(err).Str(\"StatusCode\",res.StatusCode).Msg(\"\")",
            "\t\treturn nil, err",
            "\t}",
            "\t//tip res.StatusCode to see the status code of the response",
            "\t//tip To check for errors use res.StatusCode != http.StatusOK",
            "\treturn res, nil",
            "\t// defer res.Body.Close()",
            "}"
        ],
    },
    "Parse a URL": {
        "prefix": [
            "!net parse url",
            "!net/url"
        ],
        "description": "Parse URLs using net/url package",
        "body": [
            "//tip protocol://username:password@domain:port/path?query#fragment",
            "type ParsedURL struct {",
            "\tprotocol string",
            "\tusername string",
            "\tpassword string",
            "\thostname string",
            "\tport\t string",
            "\tpathname string",
            "\tsearch   string",
            "\thash\t string",
            "}",
            "func newParsedURL(urlString string) ParsedURL {",
            "\tparsedUrl, err := url.Parse(urlString)",
            "\tif err != nil {",
            "\t\treturn ParsedURL{}",
            "\t}",
            "\tpass, _ := parsedUrl.User.Password()",
            "\treturn ParsedURL{",
            "\t\tprotocol: parsedUrl.Scheme,",
            "\t\tusername: parsedUrl.User.Username(),",
            "\t\tpassword: pass,",
            "\t\thostname: parsedUrl.Hostname(),",
            "\t\tport:\t parsedUrl.Port(),",
            "\t\tpathname: parsedUrl.Path,",
            "\t\tsearch:   parsedUrl.RawQuery,",
            "\t\thash:\t parsedUrl.Fragment,",
            "\t}",
            "}",
            ""
        ],
    },
    "unmarshal to map any json funciton": {
        "prefix": [
            "!Json-read _Data-Structures_",
        ],
        "description": "Create a function to unmarshal any json and return it as a map",
        "body": [
            "import (",
            "\"encoding/json\"",
            ")",
            "/*",
            "/*",
            "Gets a string representing a json and returns a map of key and values and an error object",
            "*/",
            "func getResources(url string) ([]map[string]any, error) {",
            "var resources []map[string]interface{}",
            "",
            "res, err := http.Get(url)",
            "if err != nil {",
            "return nil, err",
            "}",
            "defer res.Body.Close()",
            "",
            "if res.StatusCode != http.StatusOK {",
            "return nil, fmt.Errorf(\"unexpected status code: %d\", res.StatusCode)",
            "}",
            "",
            "body, err := io.ReadAll(res.Body)",
            "if err != nil {",
            "return nil, err",
            "}",
            "",
            "err = json.Unmarshal(body, &resources)",
            "if err != nil {",
            "return nil, err",
            "}",
            "",
            "return resources, nil",
            "",
            "}",
        ]
    },
    "encode/marshal json function": {
        "prefix": [
            "!Json-write to struct function _Data-Structures_",
        ],
        "description": "Creqate a function to encode a json to an array of structs",
        "body": [
            "import (",
            "\"encoding/json\"",
            ")",
            "/*",
            "A function that will get struct type and slice of that struct as parameters",
            "and return a slice of bytes representing each of those structs in []byte format",
            "*/",
            "func marshalAll[T any](items []T) ([][]byte, error) {",
            "    result := [][]byte{}",
            "    for _, value := range items{",
            "        data, err := json.Marshal(value)",
            "        if err != nil{",
            "            return nil, err",
            "        }",
            "        result  = append(result, data)",
            "    }",
            "    return result, nil",
            "}",
        ]
    },
    "encode/marshal json": {
        "prefix": [
            "!Json-write _Data-Structures_",
        ],
        "description": "Encode a json to an array of structs",
        "body": [
            "type Board struct {",
            "    Id       int    `json:\"id\"`",
            "    Name     string `json:\"name\"`",
            "    TeamId   int    `json:\"team\"`",
            "    TeamName string `json:\"team_name\"`",
            "}",
            "",
            "board := Board{",
            "    Id:       1,",
            "    Name:     \"API\",",
            "    TeamId:   9001,",
            "    TeamName: \"Backend\"",
            "}",
            "",
            "data, err := json.Marshal(board)",
            "if err != nil {",
            "    log.Fatal(err)",
            "}",
            "fmt.Println(string(data))",
            "// {\"id\":1,\"name\":\"API\",\"team\":9001,\"team_name\":\"Backend\"}",
        ]
    },
    "decode/unmarshal json": {
        "prefix": [
            "!Json-read _Data-Structures_",
        ],
        "description": "Decode a json to an array of structs",
        "body": [
            "import \"encoding/json\"",
            "//tip To decode this JSON into a slice of Issue structs, we need to know the JSON fields and their types. The standard encoding/json package uses tags to map JSON fields to struct fields.",
            "//tip The Decode method of json.Decoder streams data from an io.Reader into a Go struct, while json.Unmarshal works with data that's already in []byte format. Using a json.Decoder can be more memory-efficient because it doesn't load all the data into memory at once. json.Unmarshal is ideal for small JSON data you already have in memory. When dealing with HTTP requests and responses, you will likely use json.Decoder since it works directly with an io.Reader.",
            "type Issue struct {",
            "    Id       string `json:\"id\"`",
            "    Title    string `json:\"title\"`",
            "    Estimate int    `json:\"estimate\"`",
            "}",
            "//tip using decoder ->",
            "var issues []Issue",
            "decoder := json.NewDecoder(res.Body)",
            "if err := decoder.Decode(&issues); err != nil {",
            "    fmt.Println(\"error decoding response body\")",
            "    return",
            "}",
            "//tip using Unmarshal ->",
            "data, err := io.ReadAll(res.Body)",
            "if err != nil{",
            "    return nil, err",
            "}",
            "if err = json.Unmarshal(data, &issues); err !=nil{",
            "    return nil, err",
            "}",
            "//tip Now you can access json values",
            "for _, issue := range issues {",
            "fmt.Printf(\"Issue â€“ id: %v, title: %v, estimate: %v\n\", issue.Id, issue.Title, issue.Estimate)",
            "   // Issue â€“ id: 001-a, title: Unspaghettify code, estimate: 9001",
            "}",
        ]
    },
    "Create a channel": {
        "prefix": "!golang channel tips",
        "body": [
            "//tip Channels are a typed, thread-safe queue. Channels allow different goroutines to communicate with each other.",
            "ch := make(chan int)",
            "//tip This reads and removes a value from the channel and saves it into the variable v. This operation will block until there is a value in the channel to be read.",
            "//tip Similar to the ok value when accessing data in a map, receivers can check the ok value when receiving from a channel to test if a channel was closed.",
            "v, ok := <-ch",
            "//tip You can provide a buffer length as the second argument to make() to create a buffered channel:",
            "//tip A buffer allows the channel to hold a fixed number of values before sending blocks. This means sending on a buffered channel only blocks when the buffer is full, and receiving blocks only when the buffer is empty.",
            "ch := make(chan int, 100)",
            "//tip Channels can be explicitly closed by a sender:",
            "//tip Sending on a closed channel will cause a panic",
            "ch := make(chan int)",
            "close(ch)",
            "//tip A select statement is used to listen to multiple channels at the same time. It is similar to a switch statement but for channels.",
            "//tip The first channel with a value ready to be received will fire and its body will execute. If multiple channels are ready at the same time one is chosen randomly. The ok variable in the example above refers to whether or not the channel has been closed by the sender yet.",
            "//tip The default case in a select statement executes immediately if no other channel has a value ready. A default case stops the select statement from blocking.",
            "select {",
            "    case i, ok := <- chInts:",
            "        fmt.Println(i)",
            "    case s, ok := <- chStrings:",
            "        fmt.Println(s)",
            "   default:",
            "       // receiving from ch would block",
            "       // so do something else",
            "    }",
        ]
    },
    // "Create a struct function": {
    //     "prefix": [
    //         "!struct function create",
    //         "!struct function"
    //     ],
    //     "body": [
    //         "//tip In go functions recive a copy of the input variables to accees and change input variables themselves use pointers so your changes to input variables them selves will aplly be kept outside the function",
    //         "",
    //         "func (e ${1:struct name}) ${2:function name}(${3:input variables}) (${4:output variables}){ ",
    //         "${2:function name}StartTime := time.Now() // Record start time",
    //         "// defer keyword will execute a code when the function returns",
    //         "logger, err := SetupLogger(\"app.log\", zerolog.InfoLevel)",
    //         "if err != nil {",
    //         "panic(err)",
    //         "}",
    //         "logger.Info().Str(\"FunctionName:\",${2:function name}).Msg(FgCyan + \"${2:function name} function started\" + Reset)",
    //         "defer func() {",
    //         "logger.Info().Str(\"FunctionName:\",\"${2:function name}\").TimeDiff(\"Duration:\", time.Now(), ${2:function name}StartTime).Msgf(FgCyan+\"${2:function name} function ended. Execution time: %s\"+Reset, ${2:function name}Duration)",
    //         "}()",
    //         "${://Code here}",
    //     ]
    // },
    "serve http content": {
        "prefix": [
            "!apiserver http server _APIâ€“Server_",
        ],
        "body": [
            "import \"fmt\"",
            "import \"net/http\"",
            "import \"github.com/rs/zerolog\"",
            "import \"github.com/rs/zerolog/log\"",
            "func ${1:httpHandlerFunction}(w http.ResponseWriter, r *http.Request) {",
            "\t${1:httpHandlerFunction}StartTime := time.Now() // Record start time",
            "\tlogger, err := SetupLogger(\"app.log\", zerolog.InfoLevel)",
            "\tif err != nil {",
            "\t\tpanic(err)",
            "\t}",
            "\tlogger.Info().Str(\"FunctionName:\",\"${1:httpHandlerFunction}\").Msg(FgCyan + \"${1:httpHandlerFunction} function started\" + Reset)",
            "\tdefer func() {",
            "\t\tlogger.Info().Str(\"FunctionName:\",\"${2:function name}\").TimeDiff(\"Duration (ms)\", time.Now(), ${1:httpHandlerFunction}StartTime).Msg(FgCyan+\"${1:httpHandlerFunction} function ended.\"+Reset)",
            "\t}()",
            "\t//Code here",
            "\t${2:fmt.Fprintf(w, \"Hi there, I love %s!\", r.URL.Path[1:])}",
            "}",
            "func ${3:HTTPServerFunction}(handler func(http.ResponseWriter, *http.Request), networkInterface string, path string) {",
            "\t${3:HTTPServerFunction}StartTime := time.Now() // Record start time",
            "\t// defer keyword will execute a code when the function returns",
            "\tlogger, err := SetupLogger(\"app.log\", zerolog.InfoLevel)",
            "\tif err != nil {",
            "\t\tpanic(err)",
            "\t}",
            "\tlogger.Info().Str(\"FunctionName:\",\"${3:HTTPServerFunction}\").Msg(FgCyan + \"${3:HTTPServerFunction} function started\" + Reset)",
            "\tdefer func() {",
            "\t\tlogger.Info().Str(\"FunctionName:\",\"${2:function name}\").TimeDiff(\"Duration (ms)\", time.Now(), ${3:HTTPServerFunction}StartTime).Msg(FgCyan+\"${3:HTTPServerFunction} function ended. Execution time: %s\"+Reset)",
            "\t}()",
            "\t//Code here",
            "\thttp.HandleFunc(path, handler)",
            "\thttpErr := http.ListenAndServe(networkInterface, nil)",
            "\tif httpErr != nil {",
            "\t\tlog.Err(httpErr).Msg(\"\")",
            "\t}",
            "}",
            ""
        ],
        "description": "Create functions to serve http content on given path and netwrok interface by creating an http handler function and serving it using HandleFunc and  httplistenAndServe function"
    },
    "string to int": {
        "prefix": "!Convert string to int _Variables & Data Types_",
        "body": [
            "// Convert string to int or float in Go",
            "import \"strconv\"",
            "// Convert to int",
            "var ${1:intValue}, err = strconv.Atoi(${2:stringValue})",
            "if err != nil {",
            "   // Handle error",
            "   log.Panic().Err(err).Msg(\"\")",
            "}",
        ],
        "description": "Snippet to convert string to int"
    },
    "string to float": {
        "prefix": "!Convert string to float _Variables & Data Types_",
        "body": [
            "// Convert to float",
            "var ${3:floatValue}, err = strconv.ParseFloat(${2:stringValue}, 64)",
            "if err != nil {",
            "   // Handle error",
            "   log.Panic().Err(err).Msg(\"\")",
            "}"
        ],
        "description": "Snippet to convert string to float"
    },
    "Remove character form string": {
        "prefix": "!string remove character _Variables & Data Types_",
        "description": "Remove character from a string",
        "body": [
            "import \"strings\"",
            "${1:stringToModify} = strings.ReplaceAll(${1:stringToModify}, ${2:stringToReplace}, ${3:stringToPlaceInstead})"
        ],
    },
    "setup zerologger": {
        "prefix": "!zerologger setup _Program Structure_ _Debugging & Utilities_",
        "body": [
            "import \"os\"",
            "import \"time\"",
            "import \"github.com/rs/zerolog\"",
            "import \"github.com/rs/zerolog/log\"",
            "/*",
            "SetupLogger initializes zerolog to write to both console and a file.",
            "It sets up logging to both the console and a file, allowing for both real-time monitoring and persistent record-keeping.",
            "",
            "Parameters:",
            "",
            "- logFilePath: The path to the log file where logs will be written.",
            "",
            "- logLevel: The minimum level of logs to be written (e.g., DebugLevel, InfoLevel, ErrorLevel).",
            "",
            "Returns:",
            "",
            "- zerolog.Logger: The configured logger instance.",
            "",
            "- error: An error if the log file cannot be opened or created.",
            "",
            "*/",
            "func SetupLogger(logFilePath string, logLevel zerolog.Level) (zerolog.Logger, error) {",
            "\t// Open or create the log file",
            "\tfile, err := os.OpenFile(logFilePath, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o644)",
            "\tif err != nil {",
            "\t\treturn zerolog.Logger{}, err",
            "\t}",
            "",
            "\t// Console writer with human-friendly formatting",
            "\tconsoleWriter := zerolog.ConsoleWriter{",
            "\t\tOut:\t\tos.Stdout,",
            "\t\tTimeFormat: time.RFC3339,",
            "\t}",
            "\t",
            "\t// Set global log level",
            "\tzerolog.SetGlobalLevel(logLevel)",
            "",
            "",
            "\t// Combine both writers",
            "\tmulti := zerolog.MultiLevelWriter(consoleWriter, file)",
            "",
            "\t// Set global time format",
            "\tzerolog.TimeFieldFormat = time.RFC3339",
            "",
            "\t// Create the logger",
            "\tlogger := zerolog.New(multi).With().Caller().Timestamp().Logger()",
            "",
            "\t// Set as the global logger",
            "\tlog.Logger = logger",
            "",
            "\treturn logger, nil",
            "}"
        ],
        "description": "setup and configure zerologger"
    },
    "Read a csv file function": {
        "prefix": "!CSV-read _Data-Structures_",
        "body": [
            "",
            "/*",
            "ReadCSVAndLog reads all rows from the given CSV file, logs each row to the terminal,",
            "and returns the records and any error encountered.",
            "*/",
            "func ReadCSVAndLog(filePath string, logger zerolog.Logger) ([][]string, error) {",
            "\tfile, err := os.Open(filePath)",
            "\tif err != nil {",
            "\t\tlogger.Error().Err(err).Str(\"file\", filePath).Msg(\"Failed to open CSV file\")",
            "\t\treturn nil, err",
            "\t}",
            "\tdefer file.Close()",
            "",
            "\treader := csv.NewReader(file)",
            "\trecords, err := reader.ReadAll()",
            "\tif err != nil {",
            "\t\tlogger.Error().Err(err).Str(\"file\", filePath).Msg(\"Failed to read CSV file\")",
            "\t\treturn nil, err",
            "\t}",
            "",
            "\tfor i, row := range records {",
            "\t\tlogger.Info().Int(\"row\", i).Strs(\"fields\", row).Msg(\"CSV Row\")",
            "\t\tfmt.Printf(\"%sRow %d:%s %v\\n\", FgCyan, i, Reset, row)",
            "\t}",
            "",
            "\treturn records, nil",
            "}"
        ],
        "description": "A function to read a csv file and return its contents as a list of strings"
    },
    "Create and use channels": {
        "prefix": "!channel create",
        "body": [
            "\t// Create a channel to communicate between goroutines",
            "\tchannel := make(chan int)",
            "",
            "\tgo func() {",
            "\t\tsum := 0",
            "\t\tfor i := 0; i < 10; i++ {",
            "\t\t\tfmt.Println(\"Goroutine 1: \", i) // Print the value of i",
            "\t\t\tsum += i",
            "\t\t}",
            "\t\tchannel <- sum // Send the sum to the channel",
            "\t}()",
            "",
            "\t// Receive the sum from the channel",
            "",
            "\toutput := <-channel\t\t\t\t\t  // Will block until a value is received from the channel",
            "\tfmt.Println(\"Goroutine 1 sum: \", output) // Print the sum received from the channel"
        ],
        "description": "craete and use channel"
    },
    "Add to wait group": {
        "prefix": [
            "!waitgroup add",
            "!waitgroup increment",
            "!waitgroup wrap",
        ],
        "description": "Wrap current code in waitgroup allowing us to add the code to waitegroup created earlier using !waitgroup create",
        "body": [
            "\twg.Add(1) // So now we have 1 goroutine to wait for",
            "\tgo func() {",
            "\t\tdefer wg.Done() // Decrement the counter when the goroutine completes",
            "// Code to be executed in the goroutine",
            "\t\t $TM_SELECTED_TEXT",
            "\t}()",
        ]
    },
    "Setup goroutine with wait group": {
        "prefix": [
            "!waitgroup goroutine",
            "!waitgroup create",
            "!waitgroup setup"
        ],
        "body": [
            "import \"sync\"",
            "\t// Create a WaitGroup to wait for goroutines to finish",
            "\t// To use ",
            "\tvar wg sync.WaitGroup // Waitgroup default value is 0",
            "",
            "\t// Add a count of 1 to the WaitGroup",
            "\twg.Add(1) // So now we have 1 goroutine to wait for",
            "\tgo func() {",
            "\t\tdefer wg.Done() // Decrement the counter when the goroutine completes",
            "\t\t ${1:Write your code here} // Code to be executed in the goroutine",
            "\t}()",
            "",
            "\twg.Add(1) // Add another goroutine to wait format",
            "\tgo func() {",
            "\t\tdefer wg.Done() // Decrement the counter when the goroutine completes",
            "\t\t ${2:Write your code here} // Code to be executed in the goroutine",
            "\t}()",
            "",
            "\t// Wait for the goroutine to finish",
            "\twg.Wait() // Will block until the WaitGroup counter is 0",
            "",
            "\tlog.Info().Msg(\"All goroutines using wait group finished!\") // Print the message to the console"
        ],
        "description": "Use the sync package to create a goroutine with a wait group allowing you to run code concurrently and wait for the goroutine to finish before continuing with the rest of the code",
    },
    "add test": {
        "prefix": [
            "!unit-test _Functions_",
        ],
        "body": [
            "package \"${1:function-package-name}\"",
            "",
            "import testing",
            "/*",
            "*A test funciton for the ${2:FunctionName} function It must be stored in a file named ${3:filename}_test.go",
            "Tests in go are run using:",
            "$ go test -v",
            "tip function test names are in the format Test${2:FunctionName} and must be stored in a file named ${3:filename}_test.go",
            "*/",
            "",
            "/*",
            "# What this function dose?",
            "",
            "   This is a unit test function for the ${2:FunctionName} function.",
            "",
            "# Input parameters",
            "   t *testing.T - the testing framework object",
            "",
            "# Return parameters",
            "   It dosen't return any value only throw error if the test fails",
            "",
            "*/",
            "func Test${2:FunctionName}(t *testing.T) {",
            "\tgot := ${2:FunctionName}(${4:args})",
            "\twant := ${5:expected}",
            "",
            "\tif got != want {",
            "\t\tt.Errorf(\"${2:FunctionName}(${4:args}) = %v; want %v\", got, want)",
            "\t}",
            "}"
        ],
        "description": "Add a test for function to see if it gets the correct results based on given inputs"
    },
    "!database connection mongodb": {
        "prefix": "!dbconnect mongodb _Database_",
        "body": [
            "//tip A good rule to abide by is to only connect to db when needed we don't want to keep and open connection",
            "/*",
            "# MongoDatabaseConnection",
            "",
            "Connect to mongo db and return the connection object",
            "",
            "# Packages",
            "",
            "1. go.mongodb.org/mongo-driver/v2/mongo: mongo driver",
            "",
            "2. go.mongodb.org/mongo-driver/v2/mongo/options: mongo driver options",
            "",
            "# Parameters",
            "",
            "1. user: string - username.",
            "",
            "2. password: string - password.",
            "",
            "3. host: string - host url.",
            "",
            "4. port: string - port number.",
            "",
            "# Returns",
            "",
            "1. *mongo.Client: connection object *mongo.Client",
            "",
            "2. error: error if any error occurs during connection else nil",
            "*/",
            "func MongoDatabaseConnection(logger zerolog.Logger, username string, password string, host string, port int, timeout time.Duration) (*mongo.Client, error) {",
            "\tDatabaseConnectionStartTime := time.Now() // Record start time",
            "\tlogger.Debug().Str(\"FunctionName:\", \"DatabaseConnection\").Msg(\"DatabaseConnection function started\")",
            "\tdefer func() {",
            "\t\tlogger.Debug().Str(\"FunctionName:\", \"DatabaseConnection\").TimeDiff(\"Duration (ms)\", time.Now(), DatabaseConnectionStartTime).Msg(\"DatabaseConnection function ended.\")",
            "\t}()",
            "\tif username == \"\" || password == \"\" || host == \"\" || port == 0 {",
            "\t\terr := fmt.Errorf(\"missing required parameters\")",
            "\t\tlogger.Error().Err(err).Msg(\"Missing required parameters\")",
            "\t\treturn nil, err",
            "\t}",
            "\t// Build MongoDB URI",
            "\turi := fmt.Sprintf(\"mongodb://%s:%s@%s:%d/\", username, password, host, port)",
            "",
            "\tctx, cancel := context.WithTimeout(context.Background(), timeout)",
            "\tdefer cancel()",
            "",
            "\tclient, err := mongo.Connect(options.Client().ApplyURI(uri))",
            "\tif err != nil {",
            "\t\tlogger.Error().Err(err).Msg(\"Failed to connect to MongoDB\")",
            "\t\treturn nil, err",
            "\t}",
            "\t",
            "\tlogger.Info().Msg(\"âœ… Successfully connected to MongoDB\")",
            "",
            "\treturn client, nil",
            "}"
        ],
        "description": "Creates a function that gets mongodb credentials and returns a mongodb client"
    },
    "Benchmark Test": {
        "prefix": "benchtest",
        "body": [
            "package ${1:function-package-name}",
            "",
            "import (",
            "\t\"testing\"",
            ")",
            "",
            "// Benchmark${2:FunctionName} tests the performance of ${2:FunctionName}",
            "func Benchmark${2:FunctionName}(b *testing.B) {",
            "\tfor i := 0; i < b.N; i++ {",
            "\t\t${2:FunctionName}(${3:input args})",
            "\t}",
            "}"
        ],
        "description": "Create a benchmark test function for performance measurement"
    },
    "error handling": {
        "prefix": [
            "!trycatch _Error-Handling_",
        ],
        "body": [
            "// Error handling",
            "if err != nil {",
            "   logger.Err(err).Msg(\"${1:Error message}\")",
            "   ${2:// handle error}",
            "}"
        ],
        "description": "handle errors"
    },
    "throw fatal error": {
        "prefix": [
            "!throw error _Error-Handling_",
        ],
        "body": [
            "// Throw an error",
            "if err != nil {",
            "   panic(err)",
            "}"
        ],
        "description": "throw an error"
    },
    "create an interface": {
        "prefix": [
            "!interface create",
            "!interface"
        ],
        "body": [
            "// Interfaces are a group of methods",
            "type ${1:interface_name} interface {",
            "   ${2:method1}(${3:parameters}) ${4:return_type}",
            "   ${5:method2}(${6:parameters}) ${7:return_type}",
            "}"
        ],
        "description": "create an interface"
    },
    "maps": {
        "prefix": "!dict/map _Data-Structures_",
        "body": "var ${1:name} = map[${2|bool,string,int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,uintptr,byte,rune,float32,float64,complex64,complex128|}]${3|bool,string,int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,uintptr,byte,rune,float32,float64,complex64,complex128|}{${4:key1:value1, key2:value2,...}}"
    },
    "lists": {
        "prefix": [
            "!array _Data-Structures_",
        ],
        "body": [
            "${1:name} := []${2|bool,string,int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,uintptr,byte,rune,float32,float64,complex64,complex128|}{${3:values}}",
        ]
    },
    "if condition": {
        "prefix": [
            "!if _Control Flow_",
        ],
        "body": [
            "if ${1:condition1} {",
            "   // code to be executed if ${1:condition1} is true",
            "",
            "} else if ${2:condition2} {",
            "   // code to be executed if ${1:condition1} is false and ${2:condition2} is true",
            "",
            "} else {",
            "   // code to be executed if ${1:condition1} and ${2:condition2} are both false",
            "   ",
            "}"
        ],
        "description": "create an if condition"
    },
    "Create a switch case": {
        "prefix": [
            "!switch/match",
        ],
        "body": [
            "switch ${1:expression} {",
            "case ${2:x,y}:",
            "   // code block if ${1:expression} == x or y",
            "",
            "case ${3:z}:",
            "\t// code block if ${1:expression} == z",
            "",
            "default:",
            "   // code block if there's no mat",
            "   ",
            "}"
        ],
        "description": "create a switch case structure"
    },
    "var/const declaration": {
        "prefix": [
            "!var _Variables & Data Types_",
        ],
        "body": [
            "//* variablename starting with a capital are public (letter will be exported and can be used in other packages) while variablenames starting with a small letter are private (letter will not be exported and can not be used in other packages)",
            "${1|const,var|} ${2:variablename} ${5| ,*|}${3|bool,string,int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,uintptr,byte,rune,float32,float64,complex64,complex128|} = ${4:value}  //tip ${1:variablename} : variable &${1:variablename} : pointer to variable contains the memory address of the variable",
            "//tip In functions parameters are passed by value by default, meaning a copy of the variable is made and passed to function so the changes to the variable is not applied outside function. To allow changes to the variable to be applied outside the function you need to pass the variable as a pointer by using &${1:variablename} in the function call or pass the variable as a pointer by using *${1:variablename} in the function definition.",
        ],
        "description": "declare a variable with name and type"
    },
    "start package file template": {
        "prefix": "!Libary boilerplate _Program Structure_",
        "body": [
            "/*",
            "This is a template to build a go package. For more context and help watch this youtube video https://www.youtube.com/watch?v=sf7f4QGkwfE",
            "Go packages can't be executed without a main package and a main function.",
            "The use of packages are to share code between multiple projects or to organize code.",
            "",
            "* Pakcage names,contastants,variables and funcitons that start with a capital letter are exported and can be used by other packages.",
            "",
            "Generally a package is placed in its own directory with the same name as the package. So the ${1:ThisPackage} package would be placed in a directory named ${1:ThisPackage} and the file name will be ${1:ThisPackage}.go any other .go file with the same package name at the top in this directory will be part of ${1:ThisPackage} too",
            "",
            "now to use this package in another package you would import it like this:",
            "",
            "import \"github.com/user/repository/path to ${1:ThisPackage} folder\"",
            "*/",
            "",
            "package ${1:ThisPackage}",
            "",
            "// Sample imports",
            "import (",
            "\t\"fmt\"",
            "\t\"github.com/rs/zerolog\"",
            "\t\"github.com/rs/zerolog/log\"",
            ")",
            "",
            "",
            "// Sample for a function which can be used by other packages since it starts with a capital letter. as always its a good practice to implement logging in functions.",
            "func ThisPackageFunction(logger zerolog.Logger){",
            "\tlogger.Debug().Msg(\"Function ThisPackageFunction called\")",
            "\tdefer logger.Debug().Msg(\"Function ThisPackageFunction ended\")",
            "\tfmt.Println(\"This is a function in ${1:ThisPackage} package\")",
            "}",
            ""
        ],
        "description": "Template to create a go package"
    },
    "start a go script": {
        "prefix": [
            "!boilerplate/skeleton",
        ],
        "body": [
            "/*",
            "Pay attention in order to run this script first",
            "you need to give this script a module name",
            "the format is {REMOTE}/{USERNAME}/{module name}",
            "we give this module a name with:",
            "$ go mod init {REMOTE}/{USERNAME}/{module name}",
            "after that we need to download the specified modules",
            "and list them in go.mod go dose that automaticlly by",
            "$ go mod tidy",
            "To download and cache dependencies in the vendor directory",
            "$ go mod vendor",
            "finaly we can run the program by",
            "$ go run <gofile>",
            "To generate a binary file",
            "$ go build <gofile>",
            "tip1 A package named main has an entrypoint at the main() function. A main package is compiled into an executable program.",
            "tip2 A package by any other name is a library package. Libraries have no entry point. ",
            "tip3 Go programs are organized into packages. A package is a directory of Go code that's all compiled together. Functions, types, variables, and constants defined in one source file are visible to all other source files within the same package (directory). ",
            "tip4 The go install command compiles and installs a package or packages on your local machine for your personal usage. It installs the package's compiled binary in the GOBIN directory.",
            "tip5 to import packages in other libaries first you need to create a fodler with the name of the libary then create the script in that folder Then  you need to set the package in the script to the folder name now you create you libaray finally to use the libary in other projects you need to use import statement with the followiing format => import \"{REMOTE}/{USERNAME}/{module name}/{libary name}\" ",
            "$ go install",
            "*/",
            "/*",
            "${1:Package Documentation}",
            "*/",
            "package ${2:main}  // main is for executable programs, for libaries use any other name and put the script in a folder with the same name as the package",
            "",
            "// import packages",
            "import (",
            "\t\"os\"",
            "\t\"time\"",
            "",
            "\t\"github.com/rs/zerolog\"",
            "\t\"github.com/rs/zerolog/log\"",
            ")",
            "",
            "// ANSI color codes for terminal output",
            "const (",
            "\tReset = \"\\033[0m\"",
            "\tBold  = \"\\033[1m\"",
            "\t// Text Colors",
            "\tFgBlack   = \"\\033[30m\"",
            "\tFgRed\t = \"\\033[31m\"",
            "\tFgGreen   = \"\\033[32m\"",
            "\tFgYellow  = \"\\033[33m\"",
            "\tFgBlue\t= \"\\033[34m\"",
            "\tFgMagenta = \"\\033[35m\"",
            "\tFgCyan\t= \"\\033[36m\"",
            "\tFgWhite   = \"\\033[37m\"",
            "\t// Background Colors",
            "\tBgBlack   = \"\\033[40m\"",
            "\tBgRed\t = \"\\033[41m\"",
            "\tBgGreen   = \"\\033[42m\"",
            "\tBgYellow  = \"\\033[43m\"",
            "\tBgBlue\t= \"\\033[44m\"",
            "\tBgMagenta = \"\\033[45m\"",
            "\tBgCyan\t= \"\\033[46m\"",
            "\tBgWhite   = \"\\033[47m\"",
            ")",
            "",
            "/*",
            "SetupLogger initializes zerolog to write to both console and a file.",
            "*/",
            "func SetupLogger(logFilePath string, logLevel zerolog.Level) (zerolog.Logger, error) {",
            "\t// Open or create the log file",
            "\tfile, err := os.OpenFile(logFilePath, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o644)",
            "\tif err != nil {",
            "\t\treturn zerolog.Logger{}, err",
            "\t}",
            "",
            "\t// Console writer with human-friendly formatting",
            "\tconsoleWriter := zerolog.ConsoleWriter{",
            "\t\tOut:\t\tos.Stdout,",
            "\t\tTimeFormat: time.RFC3339,",
            "\t}",
            "\t",
            "\t// Set global log level",
            "\tzerolog.SetGlobalLevel(logLevel)",
            "",
            "",
            "\t// Combine both writers",
            "\tmulti := zerolog.MultiLevelWriter(consoleWriter, file)",
            "",
            "\t// Set global time format",
            "\tzerolog.TimeFieldFormat = time.RFC3339",
            "",
            "\t// Create the logger",
            "\tlogger := zerolog.New(multi).With().Caller().Timestamp().Logger()",
            "",
            "\t// Set as the global logger",
            "\tlog.Logger = logger",
            "",
            "\treturn logger, nil",
            "}",
            "",
            "// The function that will be executed",
            "func main() {",
            "logger, err := SetupLogger(\"app.log\", zerolog.InfoLevel)",
            "startTime := time.Now() // Record start time",
            "if err != nil {",
            "panic(err)",
            "}",
            "logger.Debug().Str(\"FunctionName:\",\"main\").Msg(\"Main function started\")",
            "defer func() {",
            "logger.Debug().Str(\"FunctionName:\",\"main\").TimeDiff(\"Duration (ms)\", time.Now(), startTime).Msg(\"Main function ended.\")",
            "}()",
            "\t${3:// Code here}",
            "",
            "}",
            ""
        ],
        "description": "set a start template for a go script"
    },
    "create arrays": {
        "prefix": "!array _Data-Structures_",
        "body": [
            "var ${1:array_name} = [${4:length}]${2|bool,string,int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,uintptr,byte,rune,float32,float64,complex64,complex128|}{${3:values}} // here length is defined",
            "",
            "var ${1:array_name} = [...]${2|bool,string,int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,uintptr,byte,rune,float32,float64,complex64,complex128|}{${3:values}} // here length is inferred"
        ],
        "description": "create an empty array with defined length or an array with values and the length will be set automaticlly"
    },
    "Create slice": {
        "prefix": "!array slice _Data-Structures_",
        "body": [
            "//  Declare a slice",
            "${1:slice_name} := []${2|bool,string,int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,uintptr,byte,rune,float32,float64,complex64,complex128|}{${3:values}}",
            "",
            "//  Create a slice from an array",
            "var myarray = [length]datatype{values} //   An array",
            "${1:slice_name} := myarray[start:end] //\tA slice made from the array",
            "//  Create a slice with make function",
            "${1:slice_name} := make([]${2|bool,string,int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,uintptr,byte,rune,float32,float64,complex64,complex128|}, length, capacity)"
        ],
        "description": "create slices which are resizeable arrays that can be created by them sleves or from an array"
    },
    "append to a slice": {
        "prefix": "!array slice append",
        "body": [
            "//  Append slice and elements",
            "slice_name = append(slice_name, element1, element2, ...)",
            "//  Append two slices",
            "slice3 = append(slice1, slice2...)"
        ],
        "description": "append elements to slice or append two slices together"
    },
    "output print": {
        "prefix": "!print _Input & Output_",
        "body": [
            "fmt.${1|Print,Println|}($TM_SELECTED_TEXT)",
        ]
    },
    "output printf": {
        "prefix": "!print format",
        "body": [
            "fmt.Printf(\"j has value: %v and type: %T\", j, j)",
        ]
    },
    // "Create maps": {
    //     "prefix": [
    //         "!maps create",
    //         "!dictionary create"
    //     ],
    //     "body": [
    //         // "var ${1:a} = map[${2|bool,string,int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,uintptr,byte,rune,float32,float64,complex64,complex128|}]${3|bool,string,int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,uintptr,byte,rune,float32,float64,complex64,complex128|}{${4:key1:value1, key2:value2,...}}",
    //         // "b := map[${2|bool,string,int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,uintptr,byte,rune,float32,float64,complex64,complex128|}]${3|bool,string,int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,uintptr,byte,rune,float32,float64,complex64,complex128|}{${4:key1:value1, key2:value2,...}}",
    //         // "",
    //         // "//  Using make function",
    //         "var ${1:a} = make(map[${2|bool,string,int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,uintptr,byte,rune,float32,float64,complex64,complex128|}]${3|bool,string,int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,uintptr,byte,rune,float32,float64,complex64,complex128|})",
    //         // "b := make(map[${2|bool,string,int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,uintptr,byte,rune,float32,float64,complex64,complex128|}]${3|bool,string,int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,uintptr,byte,rune,float32,float64,complex64,complex128|})",
    //         // "//  Delete an element from map",
    //         // "delete(map_name, key)",
    //         // "//  Check if an element is present",
    //         // "val, ok :=map_name[key]"
    //     ],
    //     "description": "Create maps dictionary like variables that are have key value structure and wont allow duplicates"
    // },
    "loop while": {
        "prefix": "!while _Control Flow_",
        "body": [
            "for ${1:sum<1000}",
            "{",
            "$TM_SELECTED_TEXT",
            "}"
        ]
    },
    "loop for range": {
        "prefix": "!foreach _Control Flow_",
        "body": [
            "for ${1:index}, ${2:variable} := range ${3:fruits_slice} {",
            "   // code to be executed for each iteration",
            "   // index will be the index of the current",
            "   // iteration and starts from 0 and value",
            "   // will be the value of the current ",
            "$TM_SELECTED_TEXT",
            "}",
        ]
    },
    "loop for": {
        "prefix": "!for _Control Flow_",
        "body": [
            "for ${1:i:=0}; ${1:i < 5}; ${1:i++}",
            "{",
            "$TM_SELECTED_TEXT",
            "",
            "   // continue will skip one itteration of a loop",
            "   // continue",
            "",
            "   // break will exit a loop",
            "   // break",
            "",
            "}"
        ]
    },
    "create a struct": {
        "prefix": "!struct _Data-Structures_",
        "body": [
            "//tip structs are a collection of variables that can be used to group related data together",
            "//tip structs can't be constants",
            "//tip Struct tags are metadata attached to struct fields. They tell other libraries or frameworks how to handle those fields",
            "//tip You can validate struct fields using tags with validation libraries like go-playground/validator this is usefull when interacting with user input or external data",
            "type ${1:struct_name} struct {",
            "   ${2:member1} ${3:datatype}; '${4:Struct tags separated by , without spaceipc}'",
            "}  // access members by ${1:struct_name}.${2:member1}",
            "// Create a variable of the struct type",
            "var ${1:struct_name} = ${5:struct_Variable}{",
            "   ${2:member1}: ${6:value},",
            "}"
        ],
        "description": "create a struct which is a collection of variables"
    },
    "Create a function": {
        "prefix": [
            "!func _Functions_",
        ],
        "body": [
            "//tip In go functions recive a copy of the input variables to accees and change input variables themselves use pointers so your changes to input variables them selves will aplly be kept outside the function",
            "//* Function name starting with a capital are public (letter will be exported and can be used in other packages) while function names starting with a small letter are private (letter will not be exported and can not be used in other packages)",
            "//! Don't forget unit tests and benchmark tests",
            "",
            "$BLOCK_COMMENT_START",
            "TIP - Function name should be descriptive and follow naming conventions",
            "TIP - Try to make function pure",
            "TIP - Don't forget to write tests ",
            "TIP - Document the funciton if needed ",
            "TIP - Each funciton must do only one thing ",
            "$BLOCK_COMMENT_END",
            "/*",
            "# ${20:function_name}",
            "",
            "TODO function_description",
            "",
            "# Packages",
            "",
            "TODO - import_package: package_description",
            "",
            "# Parameters",
            "",
            "TODO - input_name: input_type - description of the input.",
            "",
            "# Returns",
            "",
            "TODO - output_type - description of the output.",
            "",
            "",
            "*/",
            "func ${10:(e struct name)} ${20:function_name}(logger zerolog.Logger${30:, input_parameters})(${40:return_parameters}){",
            "//tip u can add unknown number of parameters by using ...datatype}",
            "//tip Adding the struct name before the function name will make the function a method of that struct giving function access to the struct members",
            "${20:function_name}StartTime := time.Now() // Record start time",
            // "logger, err := SetupLogger(\"app.log\", zerolog.InfoLevel)",
            // "if err != nil {",
            // "panic(err)",
            // "}",
            "logger.Debug().Str(\"FunctionName:\",\"${20:function_name}\").Msg(\"${20:function_name} function started\")",
            "defer func() {",
            "logger.Debug().Str(\"FunctionName:\",\"${20:function_name}\").TimeDiff(\"Duration (ms)\", time.Now(), ${20:function_name}StartTime).Msg(\"${20:function_name} function ended.\")",
            "}()",
            "//TODO Code here",
            "}"
        ],
        "description": "create a function"
    },
    "scrape web data": {
        "prefix": "!scrape web data",
        "body": [
            "import \"github.com/gocolly/colly\"",
            "import \"github.com/rs/zerolog\"",
            "import \"github.com/rs/zerolog/log\"",
            "/*",
            "ScrapeDataXpath scrapes data from a webpage using the provided XPath and URL.",
            "It initializes a new Colly collector, listens for elements matching the XPath,",
            "and returns the first matched element or an error if the scraping fails.",
            "",
            "Parameters:",
            "",
            "- logger: A zerolog.Logger instance for logging.",
            "",
            "- xpath: A string representing the XPath query to locate elements on the webpage.",
            "",
            "- url: A string representing the URL of the webpage to scrape.",
            "",
            "Returns:",
            "",
            "- *colly.XMLElement: A pointer to the first matched XMLElement.",
            "",
            "- error: An error if the scraping process encounters an issue.",
            "*/",
            "func ScrapeDataXpath(logger zerolog.Logger, xpath string, url string) (*colly.XMLElement, error) {",
            "\t// Create a new collector",
            "\tlogger.Info().Str(\"FunctionName:\", \"ScrapeDataXpath\").Msg(\"Starting to scrape data\")",
            "\tc := colly.NewCollector()",
            "\telement := &colly.XMLElement{}",
            "\tlogger.Debug().Str(\"FunctionName:\", \"ScrapeDataXpath\").Msg(\"Created c colly collector and element colley XMLElement\")",
            "\tc.OnXML(xpath, func(e *colly.XMLElement) {",
            "\t\telement = e",
            "\t})",
            "\tlogger.Debug().Str(\"FunctionName:\", \"ScrapeDataXpath\").Str(\"xpath\", xpath).Str(\"URL\", url).Msg(\"Going to start to extract element using the provided XPath and URL\")",
            "\terr := c.Visit(url)",
            "\tif err != nil {",
            "\t\tlogger.Error().Str(\"FunctionName:\", \"ScrapeDataXpath\").Err(err).Msg(\"Error visiting URL\")",
            "\t\treturn nil, err",
            "\t}",
            "\tlogger.Info().Str(\"FunctionName:\", \"ScrapeDataXpath\").Msg(\"Finished scraping data\")",
            "\treturn element, nil",
            "}"
        ],
        "description": "Scrape web data with xpath using colly"
    },
    "ANSI color codes - Text and Background": {
        "prefix": [
            "!ansi colors",
            "!ansi"
        ],
        "body": [
            "// ANSI color codes for terminal output",
            "const (",
            "    Reset       = \"\\033[0m\"",
            "    Bold        = \"\\033[1m\"",
            "    // Text Colors",
            "    FgBlack     = \"\\033[30m\"",
            "    FgRed       = \"\\033[31m\"",
            "    FgGreen     = \"\\033[32m\"",
            "    FgYellow    = \"\\033[33m\"",
            "    FgBlue      = \"\\033[34m\"",
            "    FgMagenta   = \"\\033[35m\"",
            "    FgCyan      = \"\\033[36m\"",
            "    FgWhite     = \"\\033[37m\"",
            "    // Background Colors",
            "    BgBlack     = \"\\033[40m\"",
            "    BgRed       = \"\\033[41m\"",
            "    BgGreen     = \"\\033[42m\"",
            "    BgYellow    = \"\\033[43m\"",
            "    BgBlue      = \"\\033[44m\"",
            "    BgMagenta   = \"\\033[45m\"",
            "    BgCyan      = \"\\033[46m\"",
            "    BgWhite     = \"\\033[47m\"",
            ")",
        ],
        "description": "ANSI color codes for text and background with dropdown options"
    }
}