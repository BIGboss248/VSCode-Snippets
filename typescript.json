/*

This is a collection of common code snippets for various programming tasks and patterns. https://chatgpt.com/s/t_68df9213365881919b46bdeeb98c848d

I go 10 by 10 for placeholders just in case i want to add something in between later also set place holders for comments for EZ delete

ðŸ”¹ 1. Program Structure

boilerplate/skeleton/startâ†’ basic executable program structure

Libary boilerplate / Libary skeleton / Libary start â†’ basic Libary/package structure

ðŸ”¹ 2. Variables & Data Types

var â†’ declare variable

string parse â†’ parse over string characters

var-os â†’ Read environment variable

const â†’ declare constant

type â†’ declare with type annotation (if supported)

assign â†’ variable assignment

convert var type â†’ type conversion/casting

ðŸ”¹ 3. Input & Output

print â†’ print to console

print format â†’ print to console

input â†’ read input from user

readfile â†’ read from a file

writefile â†’ write to a file

ðŸ”¹ 4. Control Flow

if â†’ if statement

one liner if â†’ one liner if statement

ifelse â†’ if-else

switch/match â†’ switch/case or match expression

for â†’ for loop (counter-based)

foreach â†’ loop over collection

while â†’ while loop

break â†’ break out of loop

continue â†’ continue to next iteration

ðŸ”¹ 5. Functions

func â†’ function definition

func oneliner / lambda â†’ Declare a one line/ arrow funciton / anonymous

unit-test â†’ function test definition

extention â†’ Extend functions of a class

ðŸ”¹ 6. Data-Structures

array â†’ array/list

array append â†’ append to array/list

array filter â†’ filter an array/list

array map â†’ Execute a function on each list item and return a new array/list

dict/map â†’ dictionary, hash map

set â†’ set

struct / class â†’ basic class or struct

Json-read â†’ parse/serialize JSON

Json-write â†’ generate JSON from data

CSV-read â†’ parse CSV file

class â†’ class definition

inherit â†’ class inheritance

ðŸ”¹ 7. Error-Handling

trycatch â†’ try/catch block

throw / raise â†’ throw an error

ðŸ”¹ 8. Concurrent and parallelism

asyncfunc â†’ async function

await â†’ await promise/future

promise/future â†’ create new promise/future

thread â†’ threading/multithreading snippet

Stream -> stream data

ðŸ”¹ 9. Debugging & Utilities

hashpassword â†’ securely hash a password

Logging_setup â†’ Setup Logging for the app

decorator -> function/class decorator

ðŸ”¹ 10. Database

dbconnect â†’ connect to a database

dbqueryrows â†’ query multiple rows

dbqueryrow â†’ query a single row

dbexec â†’ execute insert/update/delete

dbtx â†’ transaction with commit/rollback

dbclose â†’ close database connection safely

dbping â†’ check database health/connection

ðŸ”¹ 11. APIâ€“Server (exposing APIs)

apiserver â†’ start an HTTP server

apiroute â†’ define a route/endpoint handler

apiparsejson â†’ parse request body JSON

apiresjson â†’ send JSON response

apimiddleware â†’ add middleware (logging, auth, CORS)

ðŸ”¹ 12. APIâ€“Client (consuming APIs)

apiclientget â†’ make GET request to external API

apiclientpost â†’ make POST request to external API

apiclientreq â†’ generic HTTP request with headers

apiclientjson â†’ parse JSON response into struct
*/
{
	"Write file": {
		"prefix": "!writefile",
		"description": "Wrtie to a file _Input & Output_",
		"body": [
			"import path from \"path\";",
			"import fs from \"fs\";",
			"const filePath = path.join(__dirname, \"${10:filename.txt}\");",
			"const content = \"${20:content to write}\";",
			"fs.writeFileSync(filePath, content, \"utf-8\");"
		]
	},
	"Read file": {
		"prefix": "!readfile",
		"description": "Read contents of a file _Input & Output_",
		"body": [
			"$BLOCK_COMMENT_START __filename => executed code file path $BLOCK_COMMENT_END",
			"$BLOCK_COMMENT_START __dirname => executed code dir $BLOCK_COMMENT_END",
			"import path from \"path\";",
			"import fs from \"fs\";",
			"const filePath = path.join(__dirname, \"${10:filename.txt}\");",
			"const fileContent = fs.readFileSync(filePath, \"utf-8\");",
			"console.log(fileContent);"
		]
	},
	"one liner if": {
		"prefix": "!if oneliner",
		"description": "Create a one liner if statement",
		"body": "${10|condition|} ? ${20|true expression|} : ${30|false expression|}"
	},
	"Create a class": {
		"prefix": "!class",
		"body": [
			"$BLOCK_COMMENT_START TS class can be abstract $BLOCK_COMMENT_END",
			"class ${10:ClassName}{",
			"\t$BLOCK_COMMENT_START TS supports constructor overloading $BLOCK_COMMENT_END",
			"\tconstructor(){}",
			"\tconstructor(x: number){}",
			"\t${20|public,private,protected|} propertyName: string = \"value\";",
			"\tpublic methodName(){}",
			"}"
		],
		"description": "Create a class with constructor and method and property"
	},
	"Create a promise/future": {
		"prefix": [
			"!promise",
			"!future"
		],
		"description": "Create a new promise/future",
		"body": [
			"const ${10:promiseName} = new Promise<${20|unknown,string,number,boolean,any|}>((resolve, reject) => {",
			"\t// Asynchronous operation goes here",
			"\t// Call resolve(value) if successful or reject(error) if there is an error",
			"}).then(()=>{",
			"$BLOCK_COMMENT_START What to execute when promise is done without error $BLOCK_COMMENT_END",
			"}).catch(()=>{",
			"$BLOCK_COMMENT_START What to execute when promise is done with error $BLOCK_COMMENT_END",
			"});",
		]
	},
	"Oneliner function": {
		"prefix": "!func oneliner",
		"description": "Create a one liner function",
		"body": "const ${10:name} = (${20:param: type}): ${30:returnType} => {}"
	},
	"Create function": {
		"prefix": "!func",
		"description": "Create a function",
		"body": "function ${10:name}(${20:param1: type1}): ${30:returnType}{}"
	},
	"Create struct/interface": {
		"prefix": [
			"!struct",
			"!interface"
		],
		"description": "Create a struct/tyscript interface _Data-Structures_",
		"body": [
			"$BLOCK_COMMENT_START tip interface can extend another interface $BLOCK_COMMENT_END",
			"interface ${10:InterfaceName} {",
			"\t${20:propertyName}: ${30|string,number,boolean,any|};",
			"}"
		]
	},
	"Let variable with type dropdown": {
		"prefix": "!var",
		"body": [
			"$BLOCK_COMMENT_START TS has Type Inference $BLOCK_COMMENT_END",
			"let ${10:variableName}: ${20|string,number,boolean,any|}"
		],
		"description": "Create a variable _Variables & Data Types_"
	},
	"API GET request with Axois": {
		"prefix": [
			"!apiget axios",
			"!api get axios",
			"!apiget",
			"!api get"
		],
		"body": [
			"axios.defaults.baseURL = 'https://cloudflare-dns.com';",
			"$BLOCK_COMMENT_START Even with a default set you can override defaults by specifing https://domain $BLOCK_COMMENT_END",
			"const page = await axios.get('/dns-query?name=google.com', {",
			"\theaders: {",
			"\t\t'Accept': 'application/dns-json'",
			"\t}",
			"});"
		],
		"description": "Create an API get with axios"
	},
	"API get fetch": {
		"prefix": [
			"!apiget fetch",
			"!api get fetch"
		],
		"description": "make an API get request using fetch which works in modern browsers and nodeJS _APIâ€“Client (consuming APIs)_",
		"body": [
			"fetch(${10:\"https://dns.google/resolve?name=\" + encodeURIComponent(\"youtube.com\")}, {",
			"\theaders: {",
			"\t\t\"Accept\": \"application/dns\"",
			"\t}",
			"})",
			"\t.then((response) => {",
			"\t\tif (!response.ok) {",
			"\t\t\tthrow new Error(\"Network response was not ok\");",
			"\t\t}",
			"\t\treturn response.json();",
			"\t})",
			"\t.then((data) => {",
			"\t\tconsole.log(data);",
			"\t})",
			"\t.catch((error) => {",
			"\t\tconsole.error(\"There was a problem with the fetch operation:\", error);",
			"\t});"
		]
	},
	"API get XMLHttpRequest": {
		"prefix": [
			"!apiget XMLHttpRequest",
			"!api get XMLHttpRequest"
		],
		"description": "make an API get request compatible with older browsers using XMLHttpRequest _APIâ€“Client (consuming APIs)_",
		"body": [
			"interface Header {",
			"\tkey: string;",
			"\tvalue: string;",
			"}",
			"",
			"/**",
			" * Sends a GET request to the specified URL using XMLHttpRequest",
			" * @param url - The endpoint URL",
			" * @param headers - Array of headers to include in the request",
			" * @param responseType - Expected response type ('json' | 'text' | 'blob' | 'arraybuffer' | ...)",
			" * @returns Promise with the response data",
			" */",
			"function apiGET<T = unknown>(",
			"\turl: string,",
			"\theaders: Header[] = [],",
			"\tresponseType: XMLHttpRequestResponseType = \"json\"",
			"): Promise<T> {",
			"\treturn new Promise((resolve, reject) => {",
			"\t\tconst xhr = new XMLHttpRequest();",
			"",
			"\t\txhr.open(\"GET\", url, true);",
			"",
			"\t\t// Set all provided headers",
			"\t\theaders.forEach(({ key, value }) => {",
			"\t\t\txhr.setRequestHeader(key, value);",
			"\t\t});",
			"",
			"\t\txhr.responseType = responseType;",
			"",
			"\t\txhr.onload = () => {",
			"\t\t\t// onload is called when readyState === 4",
			"\t\t\tif (xhr.status >= 200 && xhr.status < 300) {",
			"\t\t\t\tresolve(xhr.response as T);",
			"\t\t\t} else {",
			"\t\t\t\treject(new Error(`Request failed with status ${xhr.status} - ${xhr.statusText}`));",
			"\t\t\t}",
			"\t\t};",
			"",
			"\t\txhr.onerror = () => {",
			"\t\t\treject(new Error(\"Network error\"));",
			"\t\t};",
			"",
			"\t\txhr.ontimeout = () => {",
			"\t\t\treject(new Error(\"Request timeout\"));",
			"\t\t};",
			"",
			"\t\t// Optional: better logging (you can remove or customize)",
			"\t\txhr.onreadystatechange = () => {",
			"\t\t\tif (xhr.readyState === 4) {",
			"\t\t\t\tconsole.log(`Request to \\${url} completed with status: ${xhr.status}`);",
			"\t\t\t}",
			"\t\t};",
			"",
			"\t\txhr.timeout = 8000; // 8 seconds",
			"",
			"\t\txhr.send();",
			"\t});",
			"}"
		],
	},
	"Bun HTTP Server": {
		"prefix": "!http bun server",
		"body": [
			"// https://bun.com/docs/runtime/http/server",
			"const server = Bun.serve({",
			"",
			"\t//* on which hostname and port server should listen",
			"\tport: 8080, // defaults to \\$BUN_PORT, \\$PORT, \\$NODE_PORT otherwise 3000, 0 will\tbe random port",
			"\thostname: \"0.0.0.0\", // defaults to \"0.0.0.0\" can be hostname",
			"",
			"\t// 10 seconds:",
			"\t// idleTimeout: 10,",
			"",
			"\t//* `routes` requires Bun v1.2.3+",
			"\troutes: {",
			"\t\t// Static routes",
			"\t\t\"/api/status\": new Response(\"OK\"),",
			"",
			"\t\t// Dynamic routes",
			"\t\t\"/users/:id\": (req) => {",
			"\t\t\treturn new Response(`Hello User ${req.params.id}!`);",
			"\t\t},",
			"",
			"\t\t// Per-HTTP method handlers",
			"\t\t\"/api/posts\": {",
			"\t\t\tGET: () => new Response(\"List posts\"),",
			"\t\t\tPOST: async (req) => {",
			"\t\t\t\tconst body = await req.json();",
			"\t\t\t\treturn Response.json({ created: true, ...body });",
			"\t\t\t},",
			"\t\t},",
			"",
			"",
			"\t\t// Wildcard route for all routes that start with \"/api/\" and aren't otherwise matched",
			"\t\t\"/api/*\": Response.json({ message: \"Not found\" }, { status: 404 }),",
			"",
			"\t\t// Redirect from /blog/hello to /blog/hello/world",
			"\t\t\"/blog/hello\": Response.redirect(\"/blog/hello/world\"),",
			"",
			"\t\t// Serve a file by lazily loading it into memory",
			"\t\t\"/favicon.ico\": Bun.file(\"./favicon.ico\"),",
			"",
			"\t\t//* Access cookies from the request",
			"\t\t\"/profile\": req => {",
			"\t\t\t// Access cookies from the request",
			"\t\t\tconst userId = req.cookies.get(\"user_id\");",
			"\t\t\tconst theme = req.cookies.get(\"theme\") || \"light\";",
			"",
			"\t\t\treturn Response.json({",
			"\t\t\t\tuserId,",
			"\t\t\t\ttheme,",
			"\t\t\t\tmessage: \"Profile page\",",
			"\t\t\t});",
			"\t\t},",
			"",
			"\t\t//* Set cookies in the response",
			"\t\t\"/login\": req => {",
			"\t\t\tconst cookies = req.cookies;",
			"",
			"\t\t\t// Set a cookie with various options",
			"\t\t\tcookies.set(\"user_id\", \"12345\", {",
			"\t\t\t\tmaxAge: 60 * 60 * 24 * 7, // 1 week",
			"\t\t\t\thttpOnly: true,",
			"\t\t\t\tsecure: true,",
			"\t\t\t\tpath: \"/\",",
			"\t\t\t});",
			"",
			"\t\t\t// Add a theme preference cookie",
			"\t\t\tcookies.set(\"theme\", \"dark\");",
			"",
			"\t\t\t// Modified cookies from the request are automatically applied to the response",
			"\t\t\treturn new Response(\"Login successful\");",
			"\t\t},",
			"",
			"\t\t//* Deleting cookies",
			"\t\t\"/logout\": req => {",
			"\t\t\t// Delete the user_id cookie",
			"\t\t\treq.cookies.delete(\"user_id\", {",
			"\t\t\t\tpath: \"/\",",
			"\t\t\t});",
			"",
			"\t\t\treturn new Response(\"Logged out successfully\");",
			"\t\t},",
			"",
			"\t},",
			"",
			"\tasync fetch(req, server) {",
			"",
			"\t\t//* Get server metrics",
			"\t\tconst serverPendingRequests = server.pendingRequests;",
			"\t\tconst serverPendingWebSockets = server.pendingWebSockets;",
			"\t\tconst chatUsers = server.subscriberCount(\"chat\"); // number of subscribers to \"chat\" channel",
			"",
			"\t\t//* Fetch client IP and port",
			"\t\tconst address = server.requestIP(req);",
			"\t\tconst clientIP = address?.address;",
			"\t\tconst clientPort = address?.port;",
			"",
			"\t\t//* Set 60 second timeout for this request",
			"\t\tserver.timeout(req, 60);",
			"\t\t// If they take longer than 60 seconds to send the body, the request will be aborted",
			"\t\tawait req.text();",
			"",
			"\t\treturn new Response(\"Done!\");",
			"\t},",
			"",
			"\t//* TLS",
			"\ttls: [",
			"\t\t{",
			"\t\t\tkey: Bun.file(\"./key1.pem\"),",
			"\t\t\tcert: Bun.file(\"./cert1.pem\"),",
			"\t\t\tserverName: \"my-server1.com\",",
			"\t\t},",
			"\t\t{",
			"\t\t\tkey: Bun.file(\"./key2.pem\"),",
			"\t\t\tcert: Bun.file(\"./cert2.pem\"),",
			"\t\t\tserverName: \"my-server2.com\",",
			"\t\t},",
			"\t],",
			"",
			"});"
		],
		"description": "Create a bun HTTP server to host and serve HTML , typescript, javascript files"
	},
}